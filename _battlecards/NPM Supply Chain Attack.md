---
permalink: /battlecards/npm_supply_chain_attack
title: NPM Supply Chain Attack

battlecard:
 title: NPM Supply Chain Attack
 category: Package Ecosystem
 scenario: NPM
 focus: 
   - vanity imports 
   - private/public repo mix-ups 
---


A developer working on a new feature uses several popular npm packages, including debug and chalk. Unbeknownst to them, the maintainer of one of these packages has fallen victim to a sophisticated phishing attack. The attacker, impersonating an npm support agent, convinced the maintainer to provide their credentials and a live TOTP code, bypassing their two-factor authentication. With control of the maintainer's account, the attacker pushes a new, malicious version of the legitimate library to the public npm registry. 

This new version includes a post-install script that executes on every developer and CI/CD system that updates the package.

The malicious script begins to scrape the local machine for valuable credentials, including cryptocurrency wallets, AWS keys, GitHub tokens, and other sensitive files. The stolen data is exfiltrated to an attacker-controlled endpoint. Within minutes, the attacker has harvested credentials from dozens of organizations that updated their dependencies. The developer's company is unaware until their internal security team receives an alert about an unauthorized API call from a CI/CD pipeline, and they begin to notice suspicious activity from developer accounts.

---

{% block type='battlecard' text='Reconnaissance' %}
### Explanation
This is the discovery and initial compromise phase of a software supply chain attack. Attackers are not directly targeting an end user's system, but rather the trusted upstream dependencies. They actively monitor for weak links in the supply chain, often by profiling package maintainers who are susceptible to social engineering. The goal is to gain access to a developer's npm or GitHub account and inject malicious code into a widely-used package.

### Insight
The trust model of the open-source ecosystem is both its greatest strength and a major weakness. Developers inherently trust that a new version of a popular package is safe to install. Attackers exploit this trust by compromising a single, high-value target (a package maintainer) to silently distribute their malware to thousands of downstream consumers.

### Practical
Auditing Developer Exposure: Understand which of your team's key contributors and maintainers are using secure account practices.

Scanning the Public Sphere: Monitor for mentions of your company's projects or key developers on dark web forums and pastebin sites for early signs of a targeted campaign.

Investigating Compromise Vectors: Analyze phishing emails or other social engineering artifacts to understand the attacker's tactics.

### Tools/Techniques
Phishing Kits: Specialized kits designed to impersonate platforms like npm or GitHub and harvest credentials.

Credential Harvesters: Scripts that collect login information, 2FA tokens, and other secrets.

Automated Scanners: Bots that query public repositories for key developers and high-value projects to target.

### Metrics/Signal
Credential Theft Alerts: Alerts generated by an Identity and Access Management (IAM) system for suspicious login attempts or credential usage.

Phishing Reports: The number of phishing emails reported by developers, indicating the volume and sophistication of ongoing campaigns.

Account Lockouts: A sudden increase in developer account lockouts or password resets could be a sign of a credential stuffing or brute-force attack.

{% endblock %}
{% block type='battlecard' text='Evaluation' %}
### Explanation
This stage involves a critical internal assessment of your company's exposure to a supply chain attack. It requires understanding what third-party dependencies you are using, how they are managed, and what permissions your CI/CD pipelines have. The goal is to identify your most critical assets and the attack vectors that could compromise them.

### Insight
Your "blast radius" is directly proportional to your dependency graph's complexity and your reliance on a single, shared master key or token. A single vulnerability can impact your entire application portfolio if it affects a core, shared dependency.

### Practical
Run a Comprehensive Dependency Audit: Use an SCA tool to map all direct and transitive dependencies across all projects.

Review your CI/CD Pipeline: Examine how secrets are passed to build and deployment scripts. Are they masked in logs? Are they stored securely?

Interview Developers: Ask team members about their dependency management habits and whether they follow the principle of least privilege.

### Tools/Techniques
SCA (Software Composition Analysis):

npm audit (built-in npm command)

Snyk

OWASP Dependency-Check

GitHub Dependabot

Code Scanning:

Semgrep

GitHub Code Scanning

Manual Review:

Use grep or your IDE to search for known malicious package names.

### Metrics/Signal
Vulnerable Dependencies: A raw count of known vulnerable dependencies found during an audit, which helps prioritize remediation efforts.

Mean Time to Remediate (MTTR): How long, on average, does it take from the moment a new vulnerability is discovered to when it is fully patched and deployed?

Dependency Tree Depth: A high number of transitive dependencies can indicate a larger attack surface.

{% endblock %}

{% block type='battlecard' text='Fortify' %}
### Explanation
Fortification is about building defenses to prevent a successful supply chain attack. The goal is to make the "right way" of handling dependencies the "easy way" for developers. This means establishing strict, automated controls and policies that reduce the risk of a malicious package being introduced into the environment.

### Insight
Developers will always choose the path of least resistance. If your security process is cumbersome, they will find workarounds. Therefore, the best security controls are those that are transparent and integrated directly into the developer's workflow.

### Practical
Enforce Phishing-Resistant 2FA: Require all developers and maintainers to use FIDO2 keys instead of TOTP or SMS.

Pin Dependencies: Use a strict package-lock.json file with npm ci in all CI/CD pipelines to ensure the exact same dependency tree is installed every time.

Disable Scripts: Use npm install --ignore-scripts to prevent arbitrary code execution in post-install hooks.

Automate Audits: Integrate SCA tools directly into your CI/CD pipeline to automatically block builds that contain known vulnerable or malicious packages.

###  Tools/Techniques
2FA Providers:

YubiKey (hardware security key)

Google Titan Security Key

CI/CD Configuration:

npm ci and package-lock.json

npm config set ignore-scripts true

Secure Code Best Practices:

Implement a policy of regular credential rotation for all API tokens and secrets.

###  Metrics/Signal
2FA Adoption Rate: The percentage of developers using phishing-resistant 2FA.

Automated Block Rate: The number of builds automatically blocked by your CI/CD system due to vulnerable dependencies.

Zero Hardcoded Secrets: Your secret scanner should report zero new hardcoded secrets in commits to your main branches.


{% endblock %}

{% block type='battlecard' text='Limit' %}
### Explanation
Limiting the blast radius assumes a breach will happen. The goal is to contain the damage when a malicious package is inevitably executed. This involves applying the principle of least privilege to both developer accounts and CI/CD environments, ensuring that a compromised system cannot cause catastrophic damage.

### Insight
A leaked credential's potential for damage is directly proportional to its permissions. A token that can only perform read-only actions is less dangerous than one with administrative privileges. You should treat API keys and environment permissions like you treat user permissionsâ€”with strict, granular control.

### Practical
Create Service-Specific Keys: Don't use a single master key for all your applications. Create a unique API key for each microservice and environment.

Scope Permissions: If a CI/CD pipeline only needs to deploy to one specific service, restrict its permissions to only that action.

Use IP Allowlisting: Configure your API providers to only accept requests from a fixed set of IP addresses used by your CI/CD runners.

### Tools/Techniques
Cloud Provider Controls:

AWS IAM policies for least privilege

Google Cloud IAM roles

Architectural Controls:

API Gateway

Network segmentation to isolate critical services.

### Metrics/Signal
Key Granularity: The ratio of API keys to services. A ratio close to 1:1 is a good sign.

Least Privilege: The percentage of accounts and service principals that adhere to the principle of least privilege.

Network Flow: The number of blocked network connections originating from a compromised environment.

{% endblock %}

{% block type='battlecard' text='Expose' %}
### Explanation
This is about visibility. How do you know an attack is happening right now? You need to collect the right signals and monitor them for anomalies. A supply chain attack has a very distinct signature: unexpected process execution, outbound network connections, or unauthorized API calls from a seemingly legitimate source. Effective exposure means having the logging, monitoring, and alerting in place to detect this signature in near real-time.

### Insight
Your application logs are a valuable source of data, but they only tell part of the story. You must also ingest and monitor logs from the third-party services themselves (e.g., npm registry logs, GitHub audit logs) and your cloud provider. Correlating these different data sources is key to getting a complete picture of an attack.

### Practical
Log Every Process Spawn: Monitor and log all new process spawns in your CI/CD environments.

Enable Provider-Level Logging: Turn on all available audit and usage logging from npm and GitHub.

Create Anomaly Detection Alerts: Set up dashboards and alerts that trigger on sudden deviations from the norm. For example, alert on a new process that makes an outbound network connection to a domain it has never connected to before.

### Tools/Techniques
Observability & APM:

Datadog

Splunk

Prometheus & Grafana

Endpoint Detection and Response (EDR):

Falcon

SentinelOne

Cloud Provider Tools:

AWS CloudTrail

Google Cloud's operations suite

###  Metrics/Signal
Unexpected Process Spawns: A sudden increase in alerts for new, unapproved processes executing on a developer machine or build runner.

Suspicious Network Traffic: A sudden shift in outbound network connections to unexpected IP ranges or domains.

Unauthorized API Calls: A high rate of failed or unauthorized API calls from a compromised credential.

{% endblock %}

{% block type='battlecard' text='eXercise' %}

### Explanation
This is where you practice for failure. You wouldn't expect a firefighter to be effective without drills; likewise, your development team can't be expected to respond to a security incident without practice. By simulating an attack in a controlled way, you can test your defenses, identify weaknesses in your processes, and build the "muscle memory" needed to respond quickly and effectively when a real incident occurs.

###  Insight
The goal of an exercise is not to pass or fail, but to learn. A drill that goes perfectly might mean your test was too easy. A drill that uncovers a major flaw in your response plan is a huge success because you found it before an attacker did. It's about building a culture of resilient engineering.

### Practical
Tabletop Exercise: Gather the team and walk through a verbal attack scenario. "A developer just reported a suspicious post-install script in a core package. What is our immediate first step? Who has the credentials to revoke the key? How do we assess the damage?" Document the answers in a runbook.

Live Fire Drill (Controlled):

Create a brand new, dummy npm account with a fake package.

Intentionally publish a malicious version of a non-critical internal package.

Start a timer and see how long it takes for (a) your automated Expose systems to detect and alert on it, and (b) for the on-call developer to follow the runbook and revoke the key.

Security Education: Use the results of these exercises to educate the wider team. Show them how quickly a compromised package can propagate. Reinforce the best practices from the Fortify stage.

### Tools/Techniques
Runbook/Playbook Documentation:

Store your incident response plan in a central, accessible place like Confluence or Notion.

Incident Management:

PagerDuty

Opsgenie

Simulated Attack Tools:

npm for publishing test packages.

###  Metrics/Signal
Time to Detect (TTD): The time from the simulated malicious package publication to the first automated alert.

Time to Remediate (TTR): The total time from the attack to the point where the malicious package is removed and the system is restored to a safe state. Your goal should be to drive this down from hours to minutes.

Runbook Accuracy: During the exercise, did the team find the runbook helpful and accurate? Note any steps that were confusing or missing.

{% endblock %}